{"chat_variant": 2, "example": {"scraped_filename": "https://docs.fetch.ai/aea-framework-documentation/contract", "context": ":0.21.5:\ncontract_api_msg = ContractApiMessage(\n    performative=ContractApiMessage.Performative.GET_STATE,\n    dialogue_reference=contract_api_dialogues.new_self_initiated_dialogue_reference(),\n    ledger_id=strategy.ledger_id,\n    contract_id=\"fetchai/erc1155:0.23.3\",\n    contract_address=strategy.contract_address,\n    callable=\"get_balance\",\n    kwargs=ContractApiMessage.Kwargs(\n        {\"agent_address\": address, \"token_id\": token_id}\n    ),\n)\n\n\nThis message will be handled by the fetchai/ledger:0.21.5 connection and then a state message will be returned with the matching state. For this to be executed correctly, the fetchai/erc1155:0.23.3 contract package needs to implement the get_balance method with the specified key word arguments. We can then send the raw message to the fetchai/ledger:0.21.5 connection using the fetchai/ledger_api:1.0.0 protocol. In this case, signing is not required.\n\nDeveloping your own\u00b6\n\nThe easiest way to get started developing your own contract is by using the scaffold command:\n\naea scaffold contract my_new_contract\n\n\nThis will scaffold a contract package called my_new_contract with three files:\n\n__init__.py\ncontract.py, containing the scaffolded contract class\ncontract.yaml containing the scaffolded configuration file\n\nOnce your scaffold is in place, you can create a build folder in the package and copy the smart contract interface (e.g. bytes code and ABI) to it. Then, specify the path to the interfaces in the contract.yaml. For instance, if you use Ethereum, then you might specify the following:\n\ncontract_interface_paths:\n    ethereum: build/my_contract.json\n\n\nwhere ethereum is the ledger id and my_contract.json is the file containing the byte code and ABI.\n\nFinally, you will want to implement the part of the contract interface you need in contract.py:\n\nfrom aea.contracts.base import Contract\nfrom aea.crypto.base import LedgerApi\n\n\nclass MyContract(Contract):\n    \"\"\"The MyContract contract class which acts as a bridge between AEA framework and ERC1155 ABI.\"\"\"\n\n    @classmethod\n    def get_create_batch_transaction(\n        cls,\n        ledger_api: LedgerApi,\n        contract_address: str,\n        deployer_address: str,\n        token_ids: List[int],\n        data: Optional[bytes] = b\"\",\n        gas: int = 300000,\n    ) -> Dict[str, Any]:\n        \"\"\"\n        Get the transaction to create a batch of tokens.\n\n        :param ledger_api: the ledger API\n        :param contract_address: the address of the contract\n        :param deployer_address: the address of the deployer\n        :param token_ids: the list of token ids for creation\n        :param data: the data to include in the transaction\n        :param gas: the gas to be used\n        :return: the transaction object\n        \"\"\"\n        # create the transaction dict\n        nonce = ledger_api.api.eth.getTransactionCount(deployer_address)\n        instance = cls.get_instance(ledger_api, contract_address)\n        tx = instance.functions.createBatch(\n            deployer_address, token_ids\n        ).buildTransaction(\n            {\n                \"gas\": gas,\n                \"gasPrice\": ledger_api.api.toWei(\"50\", \"gwei\"),\n                \"nonce\": nonce,\n            }\n        )\n        tx = cls._try_estimate_gas(ledger_api, tx)\n        return tx\n\n\nAbove, we implement a method to create a transaction, in this case a transaction to create a batch of tokens. The method will be called by the framework, specifically the fetchai/ledger:0.21.5 connection once it receives a message (see bullet point 2 above). The method first gets the latest transaction nonce of the deployer_address, then constructs the contract instance, then uses the instance to build the transaction and finally updates the gas on the transaction.\n\nIt helps to look at existing contract packages, like fetchai/erc1155:0.23.3, and skills using them, like fetchai/erc1155_client:0.11.0 and fetchai/erc1155_deploy:0.31.6, for inspiration and guidance.\n\n Back to top\nPrevious\nSkills\nNext\nDecision Maker\nCopyright \u00a9 2018 - 2023 Fetch.ai - Change cookie settings\n      \nCookie consent\n\nWe use cookies to recognize your preferences and measure the effectiveness of our documentation via the feedback widget at the bottom of every docs page. With your consent, you're helping us make this documentation better.\n\nAccept Manage settings Reject", "interactions": [{"input": "What is the purpose of ContractApiMessage in the given context?", "response": "The ContractApiMessage is used to call a specific method of a smart contract with specified key word arguments, in this case the \"get_balance\" method of the fetchai/erc1155:0.23.3 contract with the agent_address and token_id specified. The message is handled by the fetchai/ledger:0.21.5 connection, and a state message is returned with the matching state."}, {"input": "What is the easiest way to get started developing a contract?", "response": "The easiest way to get started developing a contract is by using the aea scaffold command. This will generate a package containing the scaffolded contract class and configuration file. You can then specify the path to the interfaces in the configuration file, create a build folder in the package, and copy the smart contract interface (e.g. bytes code and ABI) to it. Finally, you can implement the part of the contract interface you need in the contract class."}]}, "responses": ["ContractApiMessage is a protocol used to communicate between skills and the fetchai/ledger:0.21.5 connection. It is used to request a deploy transaction for a specific contract, create transactions to modify state in the deployed smart contract, create contract calls to execute static methods on the deployed smart contract, and query the state of the deployed smart contract.", "The easiest way to get started developing a contract is to use the Remix IDE. Remix is a web-based IDE that can handle both the compilation of your contract and its deployment onto your chain of choice. Additionally, Truffle and Brownie are two development frameworks also built to assist you. To learn more about the process from beginning to end, including how to use these frameworks, we highly suggest checking out the extremely thorough smart contract course Chainlink Labs\u2019 Lead Developer Advocate Patrick Collins gave through freeCodeCamp: Solidity, Blockchain, and Smart Contract Course \u2013 Beginner to Expert Python Tutorial."]}